""" Module to batch molecule representations """

import numpy as np

from functools import partial
from collections import OrderedDict, Iterable

from ._types import *


def _combine_incidence_sparse(all_incidence, offsets_i, offsets_j):
    indices = []
    values = []
    total_shape = np.zeros(2, dtype=np.int32)

    for (index, value, shape), off_i, off_j in zip(all_incidence, offsets_i, offsets_j):
        indices.append(index + np.expand_dims(np.array([off_i, off_j], dtype=np.int32), -1))
        values.append(value)
        total_shape += np.array(shape, dtype=np.int32)

    return np.concatenate(indices, axis=1), np.concatenate(values), tuple(total_shape)


def _combine_atom_incidence(all_atom_incidence, atom_offsets, bond_offsets):
    return _combine_incidence_sparse(all_atom_incidence, atom_offsets, bond_offsets)


def _combine_bond_incidence(all_bond_incidence, bond_index_offsets):
    return _combine_incidence_sparse(all_bond_incidence, bond_index_offsets, bond_index_offsets)


def _feature_exists(name, data):
    return name in data[0]


def _combine_feature_if_exists(name, data, combiner, result):
    if not _feature_exists(name, data):
        return

    data_name = [x[name] for x in data]
    result.append((name, combiner(data_name)))


def _compute_scopes(lengths):
    offsets = np.concatenate([np.zeros((1,), dtype=np.int32), np.cumsum(lengths, 0)[:-1]], 0)
    return np.stack([offsets, lengths], 1)


def _combine_atom_leaf(leaves, atom_offsets):
    return np.concatenate([
        leaf + offset for leaf, offset in zip(leaves, atom_offsets)
    ], axis=0)


def _combine_ring_leaf(leaves, atom_offsets, ring_leaf_offsets):
    return _combine_incidence_sparse(leaves, ring_leaf_offsets, atom_offsets)


def _offsets_from_counts(counts):
    return np.concatenate([np.zeros((1,), dtype=np.int32), np.cumsum(counts, 0)[:-1]], 0)


def _combine_ring_bond_idx(all_ring_bond_idx, bond_index_offsets):
    return np.concatenate([
        arr + offset for arr, offset in zip(all_ring_bond_idx, bond_index_offsets)
    ], axis=0)


def _cast_tensors(result, cast_function):
    if cast_function is None:
        return result

    if isinstance(cast_function, str):
        if cast_function == 'torch':
            import torch

            def cast_function(x):
                x = torch.from_numpy(x)
                if x.dtype == torch.int:
                    x = x.long()
                return x
        else:
            raise ValueError("Unknow cast target type {0}".format(cast_function))

    def cast_tensor_rec(x):
        if isinstance(x, np.ndarray):
            return cast_function(x)
        elif isinstance(x, Iterable):
            return [cast_tensor_rec(y) for y in x]
        else:
            return x

    result = OrderedDict([(n, cast_tensor_rec(t)) for n, t in result.items()])
    return result


def combine_mol_graph(graphs, return_namedtuple=False, cast_tensor=None):
    """ Combines several graphs generated by `mol2graph_single` into one single batch
    with unified indexing across the batch.

    This function reindexes as required to create consistent indices across the entire
    batch. It also adjusts some offsets in bond arrays, as those are offset by 1.

    Parameters
    ----------
    graphs: a list of tuples of outputs from `mol2graph_single`.
    return_namedtuple: if True, returns the data in the form of a named tuple. Otherwise,
        simply return a dictionary with the appropriate key-value pairs.
    cast_tensor: if not None, a python callable which converts a numpy array into
        a framework-specific tensor.

    Returns
    -------
    A tuple of 5 torch arrays, the first 4 with the same interpretation as `mol2graph_single`,
    and the last representing the limits of each of the existing graphs in the union graph.
    """
    all_atom_features = [g['atom_feature'] for g in graphs]
    all_bond_features = [g['bond_feature'] for g in graphs]

    result = []

    atom_features = np.concatenate(all_atom_features, axis=0)
    result.append(('atom_feature', atom_features))

    bond_features = np.concatenate(all_bond_features, axis=0)
    result.append(('bond_feature', bond_features))

    num_atoms = np.array([af.shape[0] for af in all_atom_features], dtype=np.int32)
    num_bonds = np.array([f.shape[0] for f in all_bond_features], dtype=np.int32)

    # We compute the offset in bond indices to be applied at the ith molecule.
    atom_index_offsets = _offsets_from_counts(num_atoms)
    bond_index_offsets = _offsets_from_counts(num_bonds)

    _combine_feature_if_exists(
        'atom_incidence', graphs,
        partial(_combine_atom_incidence, atom_offsets=atom_index_offsets, bond_offsets=bond_index_offsets),
        result)

    _combine_feature_if_exists(
        'bond_incidence', graphs, partial(_combine_bond_incidence, bond_index_offsets=bond_index_offsets), result)

    atom_scope = _compute_scopes(num_atoms)
    result.append(('atom_scope', atom_scope))

    bond_scope = _compute_scopes(num_bonds)
    result.append(('bond_scope', bond_scope))

    _combine_feature_if_exists(
        'leaf_atom', graphs, partial(_combine_atom_leaf, atom_offsets=atom_index_offsets), result)

    if _feature_exists('leaf_atom', graphs):
        num_leaf_atom = np.array([x['leaf_atom'].shape[0] for x in graphs], dtype=np.int32)
        result.append(('leaf_atom_scope', _compute_scopes(num_leaf_atom)))

    if _feature_exists('leaf_ring', graphs):
        # Number of ring leaves is given by last index of ring, provided there are any.
        num_leaf_ring = np.array([x['count']['leaf_ring'] for x in graphs], dtype=np.int32)
        leaf_ring_offset = _offsets_from_counts(num_leaf_ring)

        _combine_feature_if_exists(
            'leaf_ring', graphs,
            partial(_combine_ring_leaf, atom_offsets=atom_index_offsets, ring_leaf_offsets=leaf_ring_offset),
            result)

        result.append(('leaf_ring_scope', _compute_scopes(num_leaf_ring)))

    _combine_feature_if_exists(
        'ring_bond_idx', graphs, partial(_combine_ring_bond_idx, bond_index_offsets=bond_index_offsets), result)

    _combine_feature_if_exists(
        'ring_bond_order', graphs, np.concatenate, result)

    if 'ring' in graphs[0]['count']:
        num_rings = np.array([g['count']['ring'] for g in graphs], dtype=np.int32)
        result.append(('ring_scope', _compute_scopes(num_rings)))

    result = OrderedDict(result)

    result = _cast_tensors(result, cast_tensor)

    if return_namedtuple:
        result = dict_to_graph_data(result)

    return result


def dict_to_graph_data(data):
    atom_info = AtomInfo(
        data.get('atom_feature'),
        data.get('atom_incidence'),
        data.get('atom_scope'))

    bond_info = BondInfo(
        data.get('bond_feature'),
        data.get('bond_incidence'),
        data.get('bond_scope'))

    leaf_info = LeafInfo(
        ScopedTuple(data.get('leaf_atom'), data.get('leaf_atom_scope')),
        ScopedTuple(data.get('leaf_ring'), data.get('leaf_ring_scope')))

    ring_info = RingInfo(
        data.get('ring_bond_idx'),
        data.get('ring_bond_order'),
        data.get('ring_scope'))

    return GraphInfo(atom_info, bond_info, leaf_info, ring_info)
